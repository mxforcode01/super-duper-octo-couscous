from math import ceil
from qdrant_client import models

CRITICAL_KEYS = ("region", "country", "product", "client_type", "topic")

def _norm_meta(meta: dict | None) -> dict:
    meta = meta or {}
    # Keep only known keys; drop empties; normalize to lists of strings
    out = {}
    for k in CRITICAL_KEYS:
        v = meta.get(k, [])
        if v:
            vals = [str(x).strip() for x in (v if isinstance(v, (list, tuple, set)) else [v]) if str(x).strip()]
            if vals:
                out[k] = vals
    return out

def build_filter(meta: dict, geo_or_union: bool = True) -> models.Filter | None:
    """
    AND across keys, OR within a key.
    Geo logic: (country IN ...) OR (region IN ...) if geo_or_union else keep them in 'must'.
    """
    must, should = [], []

    countries = meta.get("country", [])
    regions   = meta.get("region", [])
    if geo_or_union and (countries or regions):
        if countries:
            should.append(models.FieldCondition(key="country", match=models.MatchAny(any=countries)))
        if regions:
            should.append(models.FieldCondition(key="region", match=models.MatchAny(any=regions)))
    else:
        if countries:
            must.append(models.FieldCondition(key="country", match=models.MatchAny(any=countries)))
        if regions:
            must.append(models.FieldCondition(key="region", match=models.MatchAny(any=regions)))

    for k in ("product", "client_type", "topic"):
        vals = meta.get(k, [])
        if vals:
            must.append(models.FieldCondition(key=k, match=models.MatchAny(any=vals)))

    if not (must or should):
        return None
    return models.Filter(must=must or None, should=should or None)

def _grouped_search_country(
    client, collection_name, query_vec, qfilter, *, pool_k, countries, per_country_min=1, per_country_max=6,
    single_country_pool=20, region_to_countries=None, regions=None, respect_user_country_order=True
):
    # Estimate number of countries for adaptive group_size
    expanded = set(countries or [])
    if region_to_countries and regions:
        for r in regions:
            expanded.update(region_to_countries.get(r, []))
    n_countries = len(expanded) if expanded else max(1, len(countries or []) or len(regions or []) or 1)

    if n_countries == 1:
        group_size = min(single_country_pool, per_country_max or single_country_pool)
    else:
        group_size = max(per_country_min, min(per_country_max, ceil(pool_k / n_countries)))

    grouped = client.search_groups(
        collection_name=collection_name,
        query_vector=query_vec,
        query_filter=qfilter,
        group_by="country",
        group_size=group_size,
        limit=1024,
        with_payload=True,
        with_vectors=False,
    )

    buckets = {}
    for g in getattr(grouped, "groups", []) or []:
        gid = getattr(g, "group_id", getattr(g, "id", None))
        if gid is not None:
            buckets[gid] = list(g.hits)

    # Round-robin to pool_k
    if not buckets:
        return []

    if respect_user_country_order and countries:
        order = [c for c in countries if c in buckets] + [c for c in buckets.keys() if c not in countries]
    else:
        order = list(buckets.keys())

    out = []
    while len(out) < pool_k and any(buckets[c] for c in order):
        for c in order:
            if buckets.get(c):
                out.append(buckets[c].pop(0))
                if len(out) >= pool_k:
                    break
    return out

def diversified_by_meta_relax(
    client,
    collection_name: str,
    query_vec,
    meta: dict | None = None,
    *,
    final_k: int = 20,          # your hard cap for the LLM
    pool_mult: int = 2,         # over-fetch factor before trimming
    relax_order: list[str] = ("topic", "product", "client_type", "region", "country"),
    geo_union: bool = True,     # (country OR region)
    region_to_countries: dict[str, list[str]] | None = None,
    per_country_min: int = 1,
    per_country_max: int = 6,
    single_country_pool: int = 20,
    respect_user_country_order: bool = True,
):
    """
    Progressive relaxation in the specified order until we collect at least final_k (or pool_k) candidates.
    Diversifies by 'country' when geo constraints present; otherwise falls back to global search.
    Returns <= final_k points sorted by score.
    """
    meta = _norm_meta(meta)
    pool_k = max(final_k * pool_mult, final_k)

    def run_once(active_meta: dict):
        qfilter = build_filter(active_meta, geo_or_union=geo_union)
        countries = active_meta.get("country", [])
        regions = active_meta.get("region", [])

        if countries or regions:
            # country-diversified
            hits = _grouped_search_country(
                client, collection_name, query_vec, qfilter,
                pool_k=pool_k, countries=countries, per_country_min=per_country_min,
                per_country_max=per_country_max, single_country_pool=single_country_pool,
                region_to_countries=region_to_countries, regions=regions,
                respect_user_country_order=respect_user_country_order
            )
        else:
            # no geo â†’ single global search
            hits = client.search(
                collection_name=collection_name,
                query_vector=query_vec,
                query_filter=qfilter,
                limit=pool_k * 2,
                with_payload=True,
                with_vectors=False,
            )
            hits = sorted(hits, key=lambda h: h.score, reverse=True)[:pool_k]
        return hits

    # 1) Strict pass
    shortlist = run_once(meta)

    # 2) Relax progressively until we have enough candidates or run out of keys
    if len(shortlist) < final_k:
        active = dict(meta)  # copy
        for key in relax_order:
            if key in active:
                active.pop(key, None)
                hits = run_once(active)
                # merge (dedupe by id)
                seen = {h.id for h in shortlist}
                for h in hits:
                    if h.id not in seen:
                        shortlist.append(h)
                        seen.add(h.id)
                if len(shortlist) >= final_k:
                    break

    # 3) If still short, drop all filters (pure semantic fallback)
    if len(shortlist) < final_k:
        fill = client.search(
            collection_name=collection_name,
            query_vector=query_vec,
            limit=final_k * 3,
            with_payload=True,
            with_vectors=False,
        )
        seen = {h.id for h in shortlist}
        for h in fill:
            if h.id not in seen:
                shortlist.append(h)
                seen.add(h.id)
            if len(shortlist) >= final_k:
                break

    # Final global sort + cap
    shortlist.sort(key=lambda h: h.score, reverse=True)
    return shortlist[:final_k]


# Example 1
meta1 = {"region": ["ASIA"], "country": ["SINGAPORE"], "client_type": ["CORPORATES"], "topic": ["S2B"], "product": ["CASH"]}
res1 = diversified_by_meta_relax(client, "my_docs_bge", query_vec, meta=meta1, final_k=20)

# Example 2
meta2 = {"region": ["ASIA"], "country": ["SINGAPORE"]}
res2 = diversified_by_meta_relax(client, "my_docs_bge", query_vec, meta=meta2, final_k=20)

# Example 3 (no filters)
meta3 = {}
res3 = diversified_by_meta_relax(client, "my_docs_bge", query_vec, meta=meta3, final_k=20)
